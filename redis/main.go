package main

import (
	"context"
	"encoding/json"
	"fmt"
	//"github.com/go-redis/redis"
	"github.com/go-redis/redis/v8"
	"io"
	"log"
	compent "main/redlock"
	"net/http"
	"sync"
	"sync/atomic"
	"time"
)

type AutoGenerated struct {
	Code  int    `json:"code"`
	ID    string `json:"id"`
	State bool   `json:"state"`
}

var (
	count int32
)

func Compress(wg *sync.WaitGroup, i int) {
	res, err := http.Get("http://localhost/12")
	if err != nil {
		log.Println(err)
	}
	defer res.Body.Close()
	fmt.Println(i, "enter")
	data, _ := io.ReadAll(res.Body)
	fmt.Println(i, "outer")
	prasejson := new(AutoGenerated)
	json.Unmarshal(data, prasejson)
	fmt.Println(prasejson)
	if prasejson.Code == 200 {
		atomic.AddInt32(&count, 1)
	}
	wg.Done()
	compent.Setkey("12", 12)
	compent.SecKill()
}

func Geter() {
	var wg sync.WaitGroup

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go Compress(&wg, i)
		fmt.Println(i)

	}
	wg.Wait()
	fmt.Println("========", count)
}

type status uint32

const (
	sopen status = iota
	closed
	unkonwn
)

func main() {

	// for i:=0;i<10;i++{
	// 	code,err:=compent.SetOp("18898186026")
	// 	if err!=nil{
	// 		log.Println(err)
	// 	}
	// 	fmt.Println(code)
	// }

	client := redis.NewClient(&redis.Options{
		Addr: "42.193.190.143:6388",
		DB:   0,
	})
	var wg sync.WaitGroup
	now := time.Now()
	defer client.Close()
	total := 100
	for i := 0; i < 100; i++ {
		wg.Add(1)

		go func() {
			defer wg.Add(-1)
			if client.SetNX(context.Background(), "xiexi", "va", time.Second*10).Val() {
				total--
				client.Del(context.Background(), "xiexi")
			}

		}()
	}
	wg.Wait()
	fmt.Println("现在的用时是:", time.Now().Sub(now), total)
	//两个结构体的竟然完全不能通用,在不同的包中间， 相当于完全不同的包了，就是严格做了语义区分
	newClient := redis.NewClient(&redis.Options{
		Addr: "42.193.190.143:6388",
		DB:   0,
	})
	fmt.Println(newClient)
}
